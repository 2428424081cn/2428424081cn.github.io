<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>高级太阳系 - 手势控制版 (增强版)</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<style>
body {
    margin: 0;
    overflow: hidden;
    background: #000;
    font-family: 'Segoe UI', sans-serif;
}

#scene-container {
    width: 100vw;
    height: 100vh;
}

/* 右上角摄像头缩略图 */
#camera-preview {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 160px;
    height: 120px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 6px;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index: 10;
}
#camera-preview video {
    width: 100%;
    height: 100%;
    transform: scaleX(-1); /* 镜像翻转摄像头画面，更符合用户直觉 */
}

/* 星球名称 HUD */
#planet-name {
    position: absolute;
    top: 20px;
    left: 20px;
    color: #ffd88b;
    font-size: 24px;
    font-weight: bold;
    letter-spacing: 2px;
    text-shadow: 0 0 10px rgba(255,200,150,0.8);
    z-index: 10;
}
</style>
</head>
<body>

<div id="scene-container"></div>
<div id="camera-preview"><video id="input-video" autoplay muted playsinline></video></div>
<div id="planet-name"></div>

<script>
/********************************************************************
 * 1. Three.js 初始化
 ********************************************************************/
const container = document.getElementById('scene-container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
camera.position.set(0, 40, 140);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.toneMapping = THREE.ACESFilmicToneMapping; // 增强光影效果
renderer.toneMappingExposure = 1.2;
container.appendChild(renderer.domElement);

const textureLoader = new THREE.TextureLoader();

// 恒星背景：使用CubeTextureLoader加载真实的星空
const cubeTextureLoader = new THREE.CubeTextureLoader();
scene.background = cubeTextureLoader.load([
    'https://threejs.org/examples/textures/cube/skyboxsun25deg/px.jpg',
    'https://threejs.org/examples/textures/cube/skyboxsun25deg/nx.jpg',
    'https://threejs.org/examples/textures/cube/skyboxsun25deg/py.jpg',
    'https://threejs.org/examples/textures/cube/skyboxsun25deg/ny.jpg',
    'https://threejs.org/examples/textures/cube/skyboxsun25deg/pz.jpg',
    'https://threejs.org/examples/textures/cube/skyboxsun25deg/nz.jpg'
]);

// 响应式设计
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});


/********************************************************************
 * 2. 太阳系：行星切换 (使用真实贴图)
 ********************************************************************/
let planets = [];
let planetIndex = 5; // 初始：土星
const planetNames = ['水星','金星','地球','火星','木星','土星','天王星','海王星'];

// 基础参数和贴图路径
const PLANET_DATA = [
    { name: '水星', size: 3, distance: 20, map: 'https://threejs.org/examples/textures/planets/mercury.jpg' },
    { name: '金星', size: 5, distance: 30, map: 'https://threejs.org/examples/textures/planets/venus.jpg' },
    { name: '地球', size: 5.5, distance: 40, map: 'https://threejs.org/examples/textures/planets/earth_atmos_4096.jpg' },
    { name: '火星', size: 4.5, distance: 50, map: 'https://threejs.org/examples/textures/planets/mars.jpg' },
    { name: '木星', size: 10, distance: 70, map: 'https://threejs.org/examples/textures/planets/jupiter.jpg' },
    { name: '土星', size: 9, distance: 95, map: 'https://threejs.org/examples/textures/planets/saturn.jpg', ring: true },
    { name: '天王星', size: 7, distance: 120, map: 'https://threejs.org/examples/textures/planets/uranus.jpg', ring: true },
    { name: '海王星', size: 7, distance: 140, map: 'https://threejs.org/examples/textures/planets/neptune.jpg' }
];

function addPlanet(data){
    const geo = new THREE.SphereGeometry(data.size, 64, 64);
    const mat = new THREE.MeshStandardMaterial({ 
        map: textureLoader.load(data.map) 
    });
    const planet = new THREE.Mesh(geo, mat);
    planet.position.x = data.distance;
    
    // 自转轴倾斜，让行星看起来更真实
    planet.rotation.z = Math.PI * (Math.random() * 0.1 + 0.05);

    if (data.ring) {
        // 土星环/天王星环使用不同颜色
        const ringColor = data.name === '土星' ? 0xaaaaaa : 0xddddff;
        const ringGeo = new THREE.RingGeometry(data.size * 1.3, data.size * 2.2, 128);
        
        // 环贴图
        const ringMap = data.name === '土星' ? textureLoader.load('https://threejs.org/examples/textures/planets/saturn_ring.png') : null;
        
        const ringMat = new THREE.MeshBasicMaterial({ 
            map: ringMap,
            color: ringColor, 
            side: THREE.DoubleSide, 
            transparent: true,
            opacity: 0.8
        });
        const ringMesh = new THREE.Mesh(ringGeo, ringMat);
        ringMesh.rotation.x = Math.PI / 2;
        planet.add(ringMesh);
    }

    scene.add(planet);
    planets.push(planet);
}

PLANET_DATA.forEach(addPlanet);

// 初始设置星球名称
document.getElementById('planet-name').innerText = planetNames[planetIndex];


/********************************************************************
 * 3. 流星特效 (优化为星群)
 ********************************************************************/
const STAR_COUNT = 5000;
const starGeometry = new THREE.BufferGeometry();
const starVertices = [];
const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, blending: THREE.AdditiveBlending });

for (let i = 0; i < STAR_COUNT; i++) {
    const x = (Math.random() - 0.5) * 4000;
    const y = (Math.random() - 0.5) * 4000;
    const z = (Math.random() - 0.5) * 4000;
    starVertices.push(x, y, z);
}
starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
const stars = new THREE.Points(starGeometry, starMaterial);
scene.add(stars);

// 流星群（代替单个流星，性能更好）
const meteorGeometry = new THREE.BufferGeometry();
const meteorMaterial = new THREE.PointsMaterial({ color: 0xffaaaa, size: 1.5, blending: THREE.AdditiveBlending, map: createSparkTexture() });
const meteorVertices = [];
const meteorVelocities = [];

for (let i = 0; i < 500; i++) {
    meteorVertices.push(
        Math.random() * 400 - 200, 
        Math.random() * 400 - 200, 
        Math.random() * 400 - 200
    );
    meteorVelocities.push(-0.5 - Math.random() * 0.5, 0, 0); // 统一向负X轴移动
}
meteorGeometry.setAttribute('position', new THREE.Float32BufferAttribute(meteorVertices, 3));
const meteorParticles = new THREE.Points(meteorGeometry, meteorMaterial);
scene.add(meteorParticles);

function createSparkTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0.3, 'rgba(255,255,255,1)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    return new THREE.CanvasTexture(canvas);
}


/********************************************************************
 * 4. 灯光 (加入环境光和太阳球体)
 ********************************************************************/
// 太阳球体 (作为光源)
const sunGeo = new THREE.SphereGeometry(15, 64, 64);
const sunMat = new THREE.MeshBasicMaterial({ 
    color: 0xffffee, 
    emissive: 0xffffee, 
    emissiveIntensity: 1 
});
const sun = new THREE.Mesh(sunGeo, sunMat);
scene.add(sun);

// 点光源 (提供光照)
const sunLight = new THREE.PointLight(0xffffff, 400, 0, 0); // 增加强度
sunLight.position.set(0, 0, 0);
scene.add(sunLight);

// 环境光 (柔化阴影)
const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
scene.add(ambientLight);


/********************************************************************
 * 5. 手势识别 Mediapipe
 ********************************************************************/
const videoEl = document.getElementById('input-video');
let cameraUtil;

let gestureZoom = 1;       
let lastSwitchTime = 0;     
let currentCameraOffset = new THREE.Vector3(0, 0, 0); // 相机目标偏移

const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
});

hands.onResults(results => {
    if (!results.multiHandLandmarks.length) {
        // 如果没有检测到手，将缩放复位到正常值
        gestureZoom = THREE.MathUtils.lerp(gestureZoom, 1, 0.05);
        return;
    }
    const lm = results.multiHandLandmarks[0];

    // 食指(8)和拇指(4)之间的归一化距离
    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

    // 缩放逻辑 (手势缩放)
    gestureZoom = THREE.MathUtils.lerp(gestureZoom, 1 + (0.3 - pinchDist) * 3, 0.1);
    gestureZoom = THREE.MathUtils.clamp(gestureZoom, 0.15, 2.5);

    // 切换逻辑 (手腕滚动)
    // 采用手腕(0)和中指基部(9)的X坐标差来判断左右倾斜
    const handRoll = lm[0].x - lm[9].x; 
    
    // 阈值：稍微大一点的倾斜才触发
    const threshold = 0.1; 
    const now = Date.now();
    
    if (Math.abs(handRoll) > threshold && now - lastSwitchTime > 600) {
        lastSwitchTime = now;
        
        // Mediapipe 的X轴方向通常是镜像的，需要反转判断
        if (handRoll < -threshold) { // 手腕向右倾斜 (手掌朝左)
            planetIndex = (planetIndex + 1) % planets.length;
        } else if (handRoll > threshold) { // 手腕向左倾斜 (手掌朝右)
            planetIndex = (planetIndex - 1 + planets.length) % planets.length;
        }
        document.getElementById('planet-name').innerText = planetNames[planetIndex];
    }
    
    // 平移逻辑 (手掌在画面中的位置) - 可用于微调视角
    // cameraUtil.width/height 是 320x240，lm.x/y 是 0到1
    currentCameraOffset.x = THREE.MathUtils.lerp(currentCameraOffset.x, (lm[0].x - 0.5) * 50, 0.1);
    currentCameraOffset.y = THREE.MathUtils.lerp(currentCameraOffset.y, -(lm[0].y - 0.5) * 50, 0.1);

});

/********************************************************************
 * 6. 摄像头启动
 ********************************************************************/
cameraUtil = new Camera(videoEl, {
    onFrame: async () => { await hands.send({image: videoEl}); },
    width: 320,
    height: 240
});
cameraUtil.start();

/********************************************************************
 * 7. 动画循环
 ********************************************************************/
function animate(){
    requestAnimationFrame(animate);
    const delta = 0.01; // 旋转速度系数

    // 移动流星群
    const positions = meteorParticles.geometry.attributes.position.array;
    for (let i = 0; i < positions.length; i += 3) {
        positions[i] += meteorVelocities[i / 3]; // X轴
        // 流星重置
        if (positions[i] < -200) {
            positions[i] = 200;
        }
    }
    meteorParticles.geometry.attributes.position.needsUpdate = true;
    
    // 行星自转
    planets.forEach(p => {
        p.rotation.y += delta * 0.1;
    });


    // 聚焦选中的星球 - 平滑移动
    const targetPlanet = planets[planetIndex];
    
    // 计算目标相机位置
    const targetPosition = new THREE.Vector3(
        targetPlanet.position.x + 30 * gestureZoom + currentCameraOffset.x,
        20 * gestureZoom + currentCameraOffset.y,
        70 * gestureZoom
    );

    // 使用 lerp 平滑移动相机
    camera.position.lerp(targetPosition, 0.04);
    
    // 平滑地将相机对准目标星球
    const targetLookAt = targetPlanet.position.clone();
    
    // 优化：避免 camera.lookAt() 调用时不断创建 Vector3
    const tempLookAt = new THREE.Vector3();
    tempLookAt.copy(camera.position).lerp(targetLookAt, 0.1); 
    camera.lookAt(tempLookAt.clone()); 


    renderer.render(scene, camera);
}

animate();

/********************************************************************
 * 8. 初始化名称
 ********************************************************************/
document.getElementById('planet-name').innerText = PLANET_DATA[planetIndex].name;
</script>
</body>
</html>
